using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Winhance.Core.Features.Common.Enums;
using Winhance.Core.Features.Common.Interfaces;
using Winhance.Core.Features.Common.Models;
using Winhance.WPF.Features.Common.Interfaces;
using Winhance.WPF.Features.Common.Models;
using Winhance.WPF.Features.Common.ViewModels;
using Winhance.WPF.Features.Customize.ViewModels;
using Winhance.WPF.Features.Optimize.ViewModels;
using Winhance.WPF.Features.SoftwareApps.Models;
using Winhance.WPF.Features.SoftwareApps.ViewModels;

namespace Winhance.WPF.Features.Common.Services
{
    /// <summary>
    /// Service for collecting configuration settings from different view models.
    /// </summary>
    public class ConfigurationCollectorService
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogService _logService;

        /// <summary>
        /// A wrapper class that implements ISettingItem for Power Plan settings
        /// </summary>
        private class PowerPlanSettingItem : ISettingItem
        {
            private readonly ConfigurationItem _configItem;
            private readonly object _originalItem;
            private string _id;
            private string _name;
            private string _description;
            private bool _isSelected;
            private string _groupName;
            private bool _isVisible;
            private ControlType _controlType;
            private int _sliderValue;

            public PowerPlanSettingItem(ConfigurationItem configItem, object originalItem)
            {
                _configItem = configItem;
                _originalItem = originalItem;
                
                // Initialize properties from the ConfigurationItem
                _id = _configItem.CustomProperties.TryGetValue("Id", out var id) ? id?.ToString() : "PowerPlanComboBox";
                _name = _configItem.Name;
                _description = _configItem.CustomProperties.TryGetValue("Description", out var desc) ? desc?.ToString() : "Power Plan setting";
                _isSelected = _configItem.IsSelected;
                _groupName = _configItem.CustomProperties.TryGetValue("GroupName", out var group) ? group?.ToString() : "Power Management";
                _isVisible = true;
                _controlType = ControlType.ComboBox;
                _sliderValue = _configItem.CustomProperties.TryGetValue("SliderValue", out var value) ? Convert.ToInt32(value) : 0;
                
                // Ensure the ConfigurationItem has the correct format
                // Make sure SelectedValue is set properly
                if (_configItem.SelectedValue == null)
                {
                    // Try to get it from PowerPlanOptions if available
                    if (_configItem.CustomProperties.TryGetValue("PowerPlanOptions", out var options) &&
                        options is List<string> powerPlanOptions &&
                        powerPlanOptions.Count > 0 &&
                        _configItem.CustomProperties.TryGetValue("SliderValue", out var sliderValue))
                    {
                        int index = Convert.ToInt32(sliderValue);
                        if (index >= 0 && index < powerPlanOptions.Count)
                        {
                            _configItem.SelectedValue = powerPlanOptions[index];
                        }
                    }
                }
                
                // Always ensure SelectedValue is set based on SliderValue if it's still null
                if (_configItem.SelectedValue == null && _configItem.CustomProperties.TryGetValue("SliderValue", out var sv))
                {
                    int index = Convert.ToInt32(sv);
                    if (_configItem.CustomProperties.TryGetValue("PowerPlanOptions", out var opt) &&
                        opt is List<string> planOptions &&
                        planOptions.Count > index && index >= 0)
                    {
                        _configItem.SelectedValue = planOptions[index];
                    }
                    else
                    {
                        // Fallback to default power plan names if PowerPlanOptions is not available
                        string[] defaultOptions = { "Balanced", "High Performance", "Ultimate Performance" };
                        if (index >= 0 && index < defaultOptions.Length)
                        {
                            _configItem.SelectedValue = defaultOptions[index];
                        }
                    }
                }
                
                // Initialize other required properties
                Dependencies = new List<SettingDependency>();
                ApplySettingCommand = null;
            }

            // Properties with getters and setters
            public string Id { get => _id; set => _id = value; }
            public string Name { get => _name; set => _name = value; }
            public string Description { get => _description; set => _description = value; }
            public bool IsSelected { get => _isSelected; set => _isSelected = value; }
            public string GroupName { get => _groupName; set => _groupName = value; }
            public bool IsVisible { get => _isVisible; set => _isVisible = value; }
            public ControlType ControlType { get => _controlType; set => _controlType = value; }
            public object? SelectedValue { get => _configItem.SelectedValue; set => _configItem.SelectedValue = value?.ToString(); }
            public int SliderValue { get => _sliderValue; set => _sliderValue = value; }
            
            // Additional required properties
            public List<SettingDependency> Dependencies { get; set; }

            public System.Windows.Input.ICommand ApplySettingCommand { get; set; }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigurationCollectorService"/> class.
        /// </summary>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="logService">The log service.</param>
        public ConfigurationCollectorService(
            IServiceProvider serviceProvider,
            ILogService logService)
        {
            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
            _logService = logService ?? throw new ArgumentNullException(nameof(logService));
        }

        /// <summary>
        /// Collects settings from all view models.
        /// </summary>
        /// <returns>A dictionary of section names and their settings.</returns>
        public async Task<Dictionary<string, IEnumerable<ISettingItem>>> CollectAllSettingsAsync()
        {
            var sectionSettings = new Dictionary<string, IEnumerable<ISettingItem>>();

            // Get all view models from the service provider
            var windowsAppsViewModel = _serviceProvider.GetService<WindowsAppsViewModel>();
            var externalAppsViewModel = _serviceProvider.GetService<ExternalAppsViewModel>();
            var customizeViewModel = _serviceProvider.GetService<CustomizeViewModel>();
            // Get individual optimization feature ViewModels (SOLID approach)
            var gamingViewModel = _serviceProvider.GetService<GamingandPerformanceOptimizationsViewModel>();
            var powerViewModel = _serviceProvider.GetService<PowerOptimizationsViewModel>();
            var privacyViewModel = _serviceProvider.GetService<PrivacyOptimizationsViewModel>();
            var updateViewModel = _serviceProvider.GetService<UpdateOptimizationsViewModel>();
            var securityViewModel = _serviceProvider.GetService<WindowsSecurityOptimizationsViewModel>();
            var explorerOptViewModel = _serviceProvider.GetService<ExplorerOptimizationsViewModel>();
            var notificationViewModel = _serviceProvider.GetService<NotificationOptimizationsViewModel>();
            var soundViewModel = _serviceProvider.GetService<SoundOptimizationsViewModel>();

            // Add settings from WindowsAppsViewModel
            if (windowsAppsViewModel != null)
            {
                await CollectWindowsAppsSettings(windowsAppsViewModel, sectionSettings);
            }

            // Add settings from ExternalAppsViewModel
            if (externalAppsViewModel != null)
            {
                await CollectExternalAppsSettings(externalAppsViewModel, sectionSettings);
            }

            // Add settings from CustomizeViewModel
            if (customizeViewModel != null)
            {
                await CollectCustomizeSettings(customizeViewModel, sectionSettings);
            }

            // Add settings from individual optimization feature ViewModels (SOLID approach)
            if (gamingViewModel != null)
            {
                await CollectFeatureSettings(gamingViewModel, "Gaming and Performance", sectionSettings);
            }
            
            if (powerViewModel != null)
            {
                await CollectFeatureSettings(powerViewModel, "Power", sectionSettings);
            }
            
            if (privacyViewModel != null)
            {
                await CollectFeatureSettings(privacyViewModel, "Privacy", sectionSettings);
            }
            
            if (updateViewModel != null)
            {
                await CollectFeatureSettings(updateViewModel, "Update", sectionSettings);
            }
            
            if (securityViewModel != null)
            {
                await CollectFeatureSettings(securityViewModel, "Security", sectionSettings);
            }
            
            if (explorerOptViewModel != null)
            {
                await CollectFeatureSettings(explorerOptViewModel, "Explorer", sectionSettings);
            }
            
            if (notificationViewModel != null)
            {
                await CollectFeatureSettings(notificationViewModel, "Notification", sectionSettings);
            }
            
            if (soundViewModel != null)
            {
                await CollectFeatureSettings(soundViewModel, "Sound", sectionSettings);
            }

            return sectionSettings;
        }

        private async Task CollectWindowsAppsSettings(WindowsAppsViewModel viewModel, Dictionary<string, IEnumerable<ISettingItem>> sectionSettings)
        {
            try
            {
                
                // Ensure the view model is initialized
                if (!viewModel.IsInitialized)
                {
                    await viewModel.LoadItemsAsync();
                }
                
                // Convert each WindowsApp to WindowsAppSettingItem
                var windowsAppSettingItems = new List<WindowsAppSettingItem>();
                
                foreach (var item in viewModel.Items)
                {
                    if (item is WindowsApp windowsApp)
                    {
                        windowsAppSettingItems.Add(new WindowsAppSettingItem(windowsApp));
                        _logService.Log(LogLevel.Debug, $"Added WindowsAppSettingItem for {windowsApp.Name}");
                    }
                }
                
                _logService.Log(LogLevel.Info, $"Created {windowsAppSettingItems.Count} WindowsAppSettingItems");
                
                // Always add WindowsApps to sectionSettings, even if empty
                sectionSettings["WindowsApps"] = windowsAppSettingItems;
                _logService.Log(LogLevel.Info, $"Added WindowsApps section with {windowsAppSettingItems.Count} items");
            }
            catch (Exception ex)
            {
                _logService.Log(LogLevel.Error, $"Error collecting WindowsApps settings: {ex.Message}");
                
                // Create some default WindowsApps as fallback
                var defaultApps = new[]
                {
                    new WindowsApp
                    {
                        Name = "Microsoft Edge",
                        PackageName = "Microsoft.MicrosoftEdge",
                        IsSelected = true,
                        Description = "Microsoft Edge browser"
                    },
                    new WindowsApp
                    {
                        Name = "Calculator",
                        PackageName = "Microsoft.WindowsCalculator",
                        IsSelected = true,
                        Description = "Windows Calculator app"
                    },
                    new WindowsApp
                    {
                        Name = "Photos",
                        PackageName = "Microsoft.Windows.Photos",
                        IsSelected = true,
                        Description = "Windows Photos app"
                    }
                };
                
                var defaultWindowsAppSettingItems = new List<WindowsAppSettingItem>();
                foreach (var app in defaultApps)
                {
                    defaultWindowsAppSettingItems.Add(new WindowsAppSettingItem(app));
                }
                
                // Always add WindowsApps to sectionSettings, even if using defaults
                sectionSettings["WindowsApps"] = defaultWindowsAppSettingItems;
                _logService.Log(LogLevel.Info, $"Added WindowsApps section with {defaultWindowsAppSettingItems.Count} default items");
            }
        }

        private async Task CollectExternalAppsSettings(ExternalAppsViewModel viewModel, Dictionary<string, IEnumerable<ISettingItem>> sectionSettings)
        {
            try
            {
                _logService.Log(LogLevel.Debug, "Collecting settings from ExternalAppsViewModel");
                
                // Ensure the view model is initialized
                if (!viewModel.IsInitialized)
                {
                    _logService.Log(LogLevel.Debug, "ExternalAppsViewModel not initialized, loading items");
                    await viewModel.LoadItemsAsync();
                }
                
                // Convert each ExternalApp to ExternalAppSettingItem
                var externalAppSettingItems = new List<ExternalAppSettingItem>();
                
                foreach (var item in viewModel.Items)
                {
                    if (item is ExternalApp externalApp)
                    {
                        externalAppSettingItems.Add(new ExternalAppSettingItem(externalApp));
                        _logService.Log(LogLevel.Debug, $"Added ExternalAppSettingItem for {externalApp.Name}");
                    }
                }
                
                _logService.Log(LogLevel.Info, $"Created {externalAppSettingItems.Count} ExternalAppSettingItems");
                
                // Add the settings to the dictionary
                sectionSettings["ExternalApps"] = externalAppSettingItems;
                _logService.Log(LogLevel.Info, $"Added ExternalApps section with {externalAppSettingItems.Count} items");
            }
            catch (Exception ex)
            {
                _logService.Log(LogLevel.Error, $"Error collecting ExternalApps settings: {ex.Message}");
                
                // Add an empty list as fallback
                sectionSettings["ExternalApps"] = new List<ISettingItem>();
                _logService.Log(LogLevel.Info, "Added empty ExternalApps section due to error");
            }
        }

        private async Task CollectCustomizeSettings(CustomizeViewModel viewModel, Dictionary<string, IEnumerable<ISettingItem>> sectionSettings)
        {
            try
            {
                _logService.Log(LogLevel.Debug, "Collecting settings from CustomizeViewModel");
                
                // Ensure the view model is initialized
                if (!viewModel.IsInitialized)
                {
                    _logService.Log(LogLevel.Debug, "CustomizeViewModel not initialized, loading settings");
                    await viewModel.LoadSettingsAsync();
                }
                
                // Collect settings directly
                var customizeItems = new List<ISettingItem>();
                
                foreach (var item in viewModel.Settings)
                {
                    if (item is ISettingItem settingItem)
                    {
                        // Skip the DarkModeToggle item to avoid conflicts with ThemeSelector
                        if (settingItem.Id == "DarkModeToggle")
                        {
                            _logService.Log(LogLevel.Debug, $"Skipping DarkModeToggle item to avoid conflicts with ThemeSelector");
                            continue;
                        }
                        
                        // Special handling for Windows Theme / Choose Your Mode
                        if (settingItem.Id == "ThemeSelector" ||
                            settingItem.Name.Contains("Windows Theme") ||
                            settingItem.Name.Contains("Theme Selector") ||
                            settingItem.Name.Contains("Choose Your Mode"))
                        {
                            // Ensure it has the correct ControlType and properties for ComboBox
                            if (settingItem is ApplicationSettingItem applicationSetting)
                            {
                                applicationSetting.ControlType = ControlType.ComboBox;
                                
                                // Get the SelectedTheme from the RegistrySetting if available
                                if (applicationSetting.RegistrySetting?.CustomProperties != null &&
                                    applicationSetting.RegistrySetting.CustomProperties.ContainsKey("SelectedTheme"))
                                {
                                    var selectedTheme = applicationSetting.RegistrySetting.CustomProperties["SelectedTheme"]?.ToString();
                                    _logService.Log(LogLevel.Debug, $"Found SelectedTheme in RegistrySetting: {selectedTheme}");
                                }
                                
                                _logService.Log(LogLevel.Debug, $"Forced ControlType to ComboBox for Theme Selector");
                            }

                            else if (settingItem is ApplicationSettingItem customizationSetting)
                            {
                                customizationSetting.ControlType = ControlType.ComboBox;
                                
                                // Get the SelectedTheme from the RegistrySetting if available
                                if (customizationSetting.RegistrySetting?.CustomProperties != null &&
                                    customizationSetting.RegistrySetting.CustomProperties.ContainsKey("SelectedTheme"))
                                {
                                    var selectedTheme = customizationSetting.RegistrySetting.CustomProperties["SelectedTheme"]?.ToString();
                                    _logService.Log(LogLevel.Debug, $"Found SelectedTheme in RegistrySetting: {selectedTheme}");
                                }
                                
                                _logService.Log(LogLevel.Debug, $"Forced ControlType to ComboBox for Theme Selector (CustomizationSetting)");
                            }
                        }
                        
                        customizeItems.Add(settingItem);
                        _logService.Log(LogLevel.Debug, $"Added setting item for {settingItem.Name}");
                    }
                }
                
                _logService.Log(LogLevel.Info, $"Collected {customizeItems.Count} customize items");
                
                // Add the settings to the dictionary
                sectionSettings["Customize"] = customizeItems;
                _logService.Log(LogLevel.Info, $"Added Customize section with {customizeItems.Count} items");
            }
            catch (Exception ex)
            {
                _logService.Log(LogLevel.Error, $"Error collecting Customize settings: {ex.Message}");
                
                // Add an empty list as fallback
                sectionSettings["Customize"] = new List<ISettingItem>();
                _logService.Log(LogLevel.Info, "Added empty Customize section due to error");
            }
        }

        /// <summary>
        /// Collects settings from a feature ViewModel that implements IFeatureViewModel.
        /// This method follows SOLID principles by working with the interface.
        /// </summary>
        /// <param name="featureViewModel">The feature ViewModel to collect settings from.</param>
        /// <param name="sectionName">The name of the section for logging and organization.</param>
        /// <param name="sectionSettings">The dictionary to add settings to.</param>
        private async Task CollectFeatureSettings(IFeatureViewModel featureViewModel, string sectionName, Dictionary<string, IEnumerable<ISettingItem>> sectionSettings)
        {
            try
            {
                _logService.Log(LogLevel.Debug, $"Collecting settings from {sectionName} feature ViewModel");
                
                // Load settings to ensure we have the latest data
                await featureViewModel.LoadSettingsAsync();
                _logService.Log(LogLevel.Debug, $"{sectionName} settings loaded, count: {featureViewModel.Settings?.Count ?? 0}");
                
                // Collect settings from the feature
                var featureItems = new List<ISettingItem>();
                
                if (featureViewModel.Settings != null && featureViewModel.Settings.Count > 0)
                {
                    foreach (var setting in featureViewModel.Settings)
                    {
                        if (setting is ISettingItem settingItem)
                        {
                            featureItems.Add(settingItem);
                            _logService.Log(LogLevel.Debug, $"Added setting item from {sectionName}: {settingItem.Name}");
                        }
                    }
                }
                
                // Add the settings to the dictionary using the section name
                if (!sectionSettings.ContainsKey(sectionName))
                {
                    sectionSettings[sectionName] = featureItems;
                }
                else
                {
                    // If section already exists, merge the items
                    var existingItems = sectionSettings[sectionName].ToList();
                    existingItems.AddRange(featureItems);
                    sectionSettings[sectionName] = existingItems;
                }
                
                _logService.Log(LogLevel.Info, $"Added {sectionName} section with {featureItems.Count} items");
                
                // Log warning if no items were collected
                if (featureItems.Count == 0)
                {
                    _logService.Log(LogLevel.Warning, $"No {sectionName} items were collected. This may indicate an initialization issue with the {sectionName} ViewModel.");
                }
            }
            catch (Exception ex)
            {
                _logService.Log(LogLevel.Error, $"Error collecting {sectionName} settings: {ex.Message}");
                
                // Add an empty list as fallback
}
                
// Always add WindowsApps to sectionSettings, even if using defaults
sectionSettings["WindowsApps"] = defaultWindowsAppSettingItems;
_logService.Log(LogLevel.Info, $"Added WindowsApps section with {defaultWindowsAppSettingItems.Count} default items");
}

private async Task CollectExternalAppsSettings(ExternalAppsViewModel viewModel, Dictionary<string, IEnumerable<ISettingItem>> sectionSettings)
{
    try
    {
        _logService.Log(LogLevel.Debug, "Collecting settings from ExternalAppsViewModel");
                
        // Ensure the view model is initialized
        if (!viewModel.IsInitialized)
        {
            _logService.Log(LogLevel.Debug, "ExternalAppsViewModel not initialized, loading items");
            await viewModel.LoadItemsAsync();
        }
                
        // Convert each ExternalApp to ExternalAppSettingItem
        var externalAppSettingItems = new List<ExternalAppSettingItem>();
                
        foreach (var item in viewModel.Items)
        {
            if (item is ExternalApp externalApp)
            {
                externalAppSettingItems.Add(new ExternalAppSettingItem(externalApp));
                _logService.Log(LogLevel.Debug, $"Added ExternalAppSettingItem for {externalApp.Name}");
            }
        }
                
        _logService.Log(LogLevel.Info, $"Created {externalAppSettingItems.Count} ExternalAppSettingItems");
                
        // Add the settings to the dictionary
        sectionSettings["ExternalApps"] = externalAppSettingItems;
        _logService.Log(LogLevel.Info, $"Added ExternalApps section with {externalAppSettingItems.Count} items");
    }
    catch (Exception ex)
    {
        _logService.Log(LogLevel.Error, $"Error collecting ExternalApps settings: {ex.Message}");
                
        // Add an empty list as fallback
        sectionSettings["ExternalApps"] = new List<ISettingItem>();
        _logService.Log(LogLevel.Info, "Added empty ExternalApps section due to error");
    }
}

private async Task CollectCustomizeSettings(CustomizeViewModel viewModel, Dictionary<string, IEnumerable<ISettingItem>> sectionSettings)
{
    try
    {
        _logService.Log(LogLevel.Debug, "Collecting settings from CustomizeViewModel");
                
        // Ensure the view model is initialized
        if (!viewModel.IsInitialized)
        {
            _logService.Log(LogLevel.Debug, "CustomizeViewModel not initialized, loading settings");
            await viewModel.LoadSettingsAsync();
        }
                
        // Collect settings directly
        var customizeItems = new List<ISettingItem>();
                
        foreach (var item in viewModel.Settings)
        {
            if (item is ISettingItem settingItem)
            {
                // Skip the DarkModeToggle item to avoid conflicts with ThemeSelector
                if (settingItem.Id == "DarkModeToggle")
                {
                    _logService.Log(LogLevel.Debug, $"Skipping DarkModeToggle item to avoid conflicts with ThemeSelector");
                    continue;
                }
                        
                // Special handling for Windows Theme / Choose Your Mode
                if (settingItem.Id == "ThemeSelector" ||
                    settingItem.Name.Contains("Windows Theme") ||
                    settingItem.Name.Contains("Theme Selector") ||
                    settingItem.Name.Contains("Choose Your Mode"))
                {
                    // Ensure it has the correct ControlType and properties for ComboBox
                    if (settingItem is ApplicationSettingItem applicationSetting)
                    {
                        applicationSetting.ControlType = ControlType.ComboBox;
                                
                        // Get the SelectedTheme from the RegistrySetting if available
                        if (applicationSetting.RegistrySetting?.CustomProperties != null &&
                            applicationSetting.RegistrySetting.CustomProperties.ContainsKey("SelectedTheme"))
                        {
                            var selectedTheme = applicationSetting.RegistrySetting.CustomProperties["SelectedTheme"]?.ToString();
                            _logService.Log(LogLevel.Debug, $"Found SelectedTheme in RegistrySetting: {selectedTheme}");
                        }
                                
                        _logService.Log(LogLevel.Debug, $"Forced ControlType to ComboBox for Theme Selector");
                    }

                    else if (settingItem is ApplicationSettingItem customizationSetting)
                    {
                        customizationSetting.ControlType = ControlType.ComboBox;
                                
                        // Get the SelectedTheme from the RegistrySetting if available
                        if (customizationSetting.RegistrySetting?.CustomProperties != null &&
                            customizationSetting.RegistrySetting.CustomProperties.ContainsKey("SelectedTheme"))
                        {
                            var selectedTheme = customizationSetting.RegistrySetting.CustomProperties["SelectedTheme"]?.ToString();
                            _logService.Log(LogLevel.Debug, $"Found SelectedTheme in RegistrySetting: {selectedTheme}");
                        }
                                
                        _logService.Log(LogLevel.Debug, $"Forced ControlType to ComboBox for Theme Selector (CustomizationSetting)");
                    }
                }
                        
                customizeItems.Add(settingItem);
                _logService.Log(LogLevel.Debug, $"Added setting item for {settingItem.Name}");
            }
        }
                
        _logService.Log(LogLevel.Info, $"Collected {customizeItems.Count} customize items");
                
        // Add the settings to the dictionary
        sectionSettings["Customize"] = customizeItems;
        _logService.Log(LogLevel.Info, $"Added Customize section with {customizeItems.Count} items");
    }
    catch (Exception ex)
    {
        _logService.Log(LogLevel.Error, $"Error collecting Customize settings: {ex.Message}");
                
        // Add an empty list as fallback
        sectionSettings["Customize"] = new List<ISettingItem>();
        _logService.Log(LogLevel.Info, "Added empty Customize section due to error");
    }
}

/// <summary>
/// Collects settings from a feature ViewModel that implements IFeatureViewModel.
/// This method follows SOLID principles by working with the interface.
/// </summary>
/// <param name="featureViewModel">The feature ViewModel to collect settings from.</param>
/// <param name="sectionName">The name of the section for logging and organization.</param>
/// <param name="sectionSettings">The dictionary to add settings to.</param>
private async Task CollectFeatureSettings(IFeatureViewModel featureViewModel, string sectionName, Dictionary<string, IEnumerable<ISettingItem>> sectionSettings)
{
    try
    {
        _logService.Log(LogLevel.Debug, $"Collecting settings from {sectionName} feature ViewModel");
                
        // Load settings to ensure we have the latest data
        await featureViewModel.LoadSettingsAsync();
        _logService.Log(LogLevel.Debug, $"{sectionName} settings loaded, count: {featureViewModel.Settings?.Count ?? 0}");
                
        // Collect settings from the feature
        var featureItems = new List<ISettingItem>();
                
        if (featureViewModel.Settings != null && featureViewModel.Settings.Count > 0)
        {
            foreach (var setting in featureViewModel.Settings)
            {
                if (setting is ISettingItem settingItem)
                {
                    featureItems.Add(settingItem);
                    _logService.Log(LogLevel.Debug, $"Added setting item from {sectionName}: {settingItem.Name}");
                }
            }
        }
                
        // Add the settings to the dictionary using the section name
        if (!sectionSettings.ContainsKey(sectionName))
        {
            sectionSettings[sectionName] = featureItems;
        }
        else
        {
            // If section already exists, merge the items
            var existingItems = sectionSettings[sectionName].ToList();
            existingItems.AddRange(featureItems);
            sectionSettings[sectionName] = existingItems;
        }
                
        _logService.Log(LogLevel.Info, $"Added {sectionName} section with {featureItems.Count} items");
                
        // Log warning if no items were collected
        if (featureItems.Count == 0)
        {
            _logService.Log(LogLevel.Warning, $"No {sectionName} items were collected. This may indicate an initialization issue with the {sectionName} ViewModel.");
        }
    }
    catch (Exception ex)
    {
        _logService.Log(LogLevel.Error, $"Error collecting {sectionName} settings: {ex.Message}");
                
        // Add an empty list as fallback
        sectionSettings[sectionName] = new List<ISettingItem>();
        _logService.Log(LogLevel.Info, $"Added empty {sectionName} section due to error");
    }
}
}
}